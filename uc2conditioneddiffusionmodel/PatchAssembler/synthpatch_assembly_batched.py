# File Name:     synthpatch_assembly_batched.py
# License:       Apache 2.0 License
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		
# Description: 
# This script analyses the content in a folder and generates the corresponding 
# "big assembled image" for a target overlapping factor
#
# Note: we expect synth RGB patches to have been generated by 
#       image_gen2_Poitiers.py script
#       which only can be run with a powerful GPU

import cv2
import heapq
import matplotlib.pyplot as plt
import numpy as np
import os
from PIL import Image
import random
from scipy.ndimage import gaussian_filter, label
from skimage.transform import resize
from skimage import io, util
import time
import math

# available_cities_IDs = ['Madrid', 'Paris', 'Toulouse', 'Poitiers', 'Bordeaux', 'Limoges', 'Clermont-Ferrand', 'Troyes', 'Le Mans', 'Angers', 'Niort',] # 'Rouen']
available_cities_IDs = ['Paris',]



def count_and_extract_file_clues(folder_name: str, filename_start: str, filename_extension: str):
    """
    Counts files in the specified folder that start with a given string and have a specified extension,
    and extracts the portion of the filename between the start and the extension.

    Args:
        folder_name (str): The name of the folder to search.
        filename_start (str): The initial string the files must start with.
        filename_extension (str): The extension of the files to search for.

    Returns:
        tuple: A tuple containing:
            - An integer representing the number of files matching the criteria.
            - A list of strings with the portion of the filename between the start and the extension.
    """
    # Initialize counter and list for matching files
    count = 0
    filename_portions = []

    # Iterate through all files in the specified folder
    for file_name in os.listdir(folder_name):
        # Check if file name starts with the specified start string and ends with the specified extension
        if file_name.startswith(filename_start) and file_name.endswith(filename_extension):
            # Increment counter
            count += 1
            # Extract the portion of the filename between the start and the extension
            extracted_part = file_name[len(filename_start):-len(filename_extension)]
            filename_portions.append(extracted_part)

    return count, filename_portions


def get_synthS2_image(base_path, city_id, filename):
    osm_566_path = base_path + city_id + '/'
    original_rgb_img = cv2.imread(osm_566_path + filename)
    # Do not forget that OpenCV read images in BGR order.
    original_rgb_img = cv2.cvtColor(original_rgb_img, cv2.COLOR_BGR2RGB)
    # Careful!!! Surce image was normalized to possitive values: [0, 1].
    # While target S2 RGB images were normalized in a different way [-1, 1].
    original_rgb_img = original_rgb_img.astype(np.float32)
    return original_rgb_img


def get_candidate_patch_filenames(spec_str, base_path, city_id, col, row, epoch_i=34, diff_steps=50):
    filename_start = f"synthS2_{city_id}_{spec_str}m{epoch_i:03}_c{col:03}_r{row:03}_i{diff_steps:03}_v"
    filename_extension = ".png"
    osm_566_path = base_path + city_id + '/'
    count, parts = count_and_extract_file_clues(osm_566_path, filename_start, filename_extension)
    list_filenames = []
    for srt_portion in parts:
        filename = filename_start + srt_portion + filename_extension
        list_filenames.append(filename)
    return list_filenames, count


def save_rgb_image(image_array: np.ndarray, file_path: str) -> None:
    """Saves a 3D numpy array (RGB image) to disk as an image file.
    
    Args:
        image_array (np.ndarray): A 3D numpy array of type float with shape (height, width, 3).
                                  Values are expected to be in the range [0, 255].
        file_path (str): The path where the image will be saved.
        
    Raises:
        ValueError: If the input array is not a 3D array with 3 channels (RGB).
    """
    # Check if the input array has the correct shape
    if image_array.ndim != 3 or image_array.shape[2] != 3:
        raise ValueError("Input array must be a 3D array with shape (height, width, 3).")
    # Ensure the array values are within the expected range
    image_array = np.clip(image_array, 0, 255)
    # Convert the float array to uint8
    image_array = image_array.astype(np.uint8)
    # Create a PIL image from the numpy array
    image = Image.fromarray(image_array)
    # Save the image to the specified file path
    image.save(file_path)


def resize_image_with_filter(image: np.ndarray, new_size: tuple) -> np.ndarray:
    """
    Resizes a 3D numpy array representing an RGB image to a new specified size after applying a Gaussian filter.
    
    Args:
        image (np.ndarray): 3D numpy array of shape (height, width, 3) representing the input RGB image.
        new_size (tuple): Tuple (new_height, new_width) specifying the desired output image size.
        
    Returns:
        np.ndarray: 3D numpy array of shape (new_height, new_width, 3) representing the resized RGB image.
    """
    # Apply Gaussian filter to smooth the image and avoid aliasing artifacts
    # filtered_image = gaussian_filter(image, sigma=1)
    
    # Resize the filtered image to the new size
    resized_image = resize(image, new_size, anti_aliasing=True, mode='reflect')
    return resized_image


def check_extent_file(city_id, base_path):
    filename = f'np_extent_{city_id}_EPSG_3857.npz'
    extent_file = np.load(base_path + filename)
    extent_reg = extent_file['extent_reg']
    return extent_reg.shape[0], extent_reg.shape[1]


# def randomPatch(texture, patchLength):
#     h, w, _ = texture.shape
#     i = np.random.randint(h - patchLength)
#     j = np.random.randint(w - patchLength)

#     return texture[i:i+patchLength, j:j+patchLength]


def L2OverlapDiff(patch, patchLength, overlap, res, y, x):
    error = 0

    if x > 0:
        left = patch[:, :overlap] - res[y:y+patchLength, x:x+overlap]
        error += np.sum(left**2)

    if y > 0:
        up   = patch[:overlap, :] - res[y:y+overlap, x:x+patchLength]
        error += np.sum(up**2)

    if x > 0 and y > 0:
        corner = patch[:overlap, :overlap] - res[y:y+overlap, x:x+overlap]
        error -= np.sum(corner**2)

    return np.sqrt(error)
 


def count_near_white_pixels(image: np.ndarray, tolerance: float = 0.02) -> int:
    """Counts the number of pixels close to white within a given tolerance.
    
    Args:
        image (np.ndarray): Input image as an RGB numpy array.
        tolerance (float): Tolerance level for determining closeness to white.
        
    Returns:
        int: Number of pixels close to white.
    """
    # Validate input image dimensions
    if image.ndim != 3 or image.shape[2] != 3:
        raise ValueError("Input image must be an RGB image with 3 channels.")
    
    # Calculate the white color threshold
    white_threshold = 255 * (1 - tolerance)
    
    # Create a mask for pixels that are close to white
    white_mask = np.all(image >= white_threshold, axis=2)
    
    # Count the number of pixels that match the white mask
    white_pixel_count = np.sum(white_mask)
    
    return white_pixel_count




def detect_white_blobs(image: np.ndarray, threshold: int = 250) -> list:
    """
    Detects contiguous blobs of nearly white color in an RGB image.

    Args:
        image (np.ndarray): Input RGB image as a NumPy array.
        threshold (int, optional): Threshold value for detecting nearly white pixels. Defaults to 250.

    Returns:
        list: A list containing the number of pixels in each detected blob. Returns None if no blobs are found.
    """
    # Validate input
    if image.ndim != 3 or image.shape[2] != 3:
        raise ValueError("Input image must be an RGB image with 3 channels.")
    # Create a binary mask where pixels are nearly white
    white_mask = (image[:, :, 0] > threshold) & (image[:, :, 1] > threshold) & (image[:, :, 2] > threshold)
    # Label connected regions in the binary mask
    labeled_array, num_features = label(white_mask)
    # If no blobs are detected, return None
    if num_features == 0:
        return None
    # Compute the size of each blob
    blob_sizes = [np.sum(labeled_array == i) for i in range(1, num_features + 1)]
    return blob_sizes




def selectBestPatch(spec_str, base_path, city_id, col, row, target_osm_res, t_ovelap_margin, rgb_canvas, canvas_pixel_y, canvas_pixel_x, max_cloud_size_px):
    """
    This function selects the best candidate synthetic patch among all the available for the selected coordinates.
    
    Args:
        spec_str (str): "IR" or "RGB" according to spectral bands
        base_path (str): path where we can find the available (and already synthetized) patches
        city_id (str): ID for the Tile or city
        col (int): desired coordinate in full patch units
        row (int): desired coordinate in full patch units
        target_osm_res (int): pixel target size to resize patch images (which usually will have a different and bigger size)
        t_ovelap_margin (int): pixel width of the overlapping region in the target resolution
        rgb_canvas (np.ndarray): 3D numpy array of shape (height, width, 3) representing the RGB image which we are composing.
        canvas_pixel_y (int): coordinates in pixels of the left upper corner for the canvas to fill in
        canvas_pixel_x (int): coordinates in pixels of the left upper corner for the canvas to fill in
        
        note: canvas_pixel coordinates will provide a plave where we find a portion of already existing values from previous patches, because of the overlap among patches.
        
    Returns:
        np.ndarray: 3D numpy array of the selected & resized RGB patch.
    """
    max_patches_per_location = 50
    min_error = np.inf 
    selected_patches = [None,None,None]
    debug_selected_filenames = ['','','']
    num_candidates = 0
    # Obtain the number of variants available for that patch position
    list_filenames, count = get_candidate_patch_filenames(spec_str, base_path, city_id, col, row, epoch_i=34, diff_steps=50)
    for filename in list_filenames:
        original_rgb_patch = get_synthS2_image(base_path, city_id, filename) # 566 image
        scaled_patch = resize_image_with_filter(original_rgb_patch, (target_osm_res,target_osm_res))
        current_measured_distance = L2OverlapDiff(scaled_patch, target_osm_res, t_ovelap_margin, rgb_canvas, canvas_pixel_y, canvas_pixel_x)
        list_clouds = detect_white_blobs(original_rgb_patch, threshold=250)
        if list_clouds is not None:
            for potential_cloud in list_clouds:
                if potential_cloud > max_cloud_size_px:
                    # plt.figure()
                    # plt.imshow(original_rgb_patch/255.0)
                    # plt.title(filename)
                    # plt.show()
                    continue
        if spec_str == 'IR':
            # we try to avoid clouds
            num_white_pixels = count_near_white_pixels(scaled_patch, tolerance = 0.02)
            if num_white_pixels > max_cloud_size_px/2:
                current_measured_distance = current_measured_distance + num_white_pixels*2500
        if current_measured_distance < min_error:
            min_error = current_measured_distance
            selected_patches[1] = selected_patches[0]
            selected_patches[2] = selected_patches[1]
            debug_selected_filenames[1] = debug_selected_filenames[0]
            debug_selected_filenames[2] = debug_selected_filenames[1]
            selected_patches[0] = scaled_patch
            debug_selected_filenames[0] = filename
            num_candidates = num_candidates + 1
    if num_candidates >= 3:
        random_selected = random.randint(0,2)
    elif num_candidates > 0:
        random_selected = random.randint(0,num_candidates-1)
    else:
        # All images have large clouds!!
        print(f'ERROR: ALL patches have clouds !!! in {city_id} {col} {row}')
        random_selected = 0
        random_id = random.randint(0,max_patches_per_location-1)
        filename = list_filenames[random_id]
        original_rgb_patch = get_synthS2_image(base_path, city_id, filename) # 566 image
        scaled_patch = resize_image_with_filter(original_rgb_patch, (target_osm_res,target_osm_res))
        debug_selected_filenames[random_selected] = filename
        selected_patches[random_selected] = scaled_patch
    print(f'selected: {debug_selected_filenames[random_selected]}')
    if spec_str == 'IR':
        # Sometimes appear rar RGB colors in the expected gray colored NIR
        # So, we only consider G channel
        selected_patches[random_selected][:,:,0] = selected_patches[random_selected][:,:,1]
        selected_patches[random_selected][:,:,2] = selected_patches[random_selected][:,:,1]
    return selected_patches[random_selected]


def selectRandomPatch(spec_str, base_path, city_id, col, row, target_osm_res, forced_candidate=-1):
    """
        This function selects a random candidate synthetic patch among all the available for the selected coordinates.
    
    Args:
        spec_str (str): "IR" or "RGB" according to spectral bands
        base_path (str): path where we can find the available (and already synthetized) patches
        city_id (str): ID for the Tile or city
        col (int): desired coordinate in full patch units
        row (int): desired coordinate in full patch units
        target_osm_res (int): pixel target size to resize patch images (which usually will have a different and bigger size)
        forced_candidate (int): if initialized, the function takes THAT candidate ID
        
    Returns:
        np.ndarray: 3D numpy array of the randomly selected & resized RGB patch.
    """
    list_filenames, count = get_candidate_patch_filenames(spec_str, base_path, city_id, col, row, epoch_i=34, diff_steps=50)
    if forced_candidate >= 0 and forced_candidate < count:
        candidate_filename = list_filenames[forced_candidate]
    else:
        candidate_filename = list_filenames[random.randint(0, count-1)]
    original_rgb_patch = get_synthS2_image(base_path, city_id, candidate_filename) # 566 image
    scaled_patch = resize_image_with_filter(original_rgb_patch, (target_osm_res,target_osm_res))
    print(f'selected: {candidate_filename}')
    return scaled_patch


def minCutPath(errors):
    # dijkstra's algorithm vertical
    pq = [(error, [i]) for i, error in enumerate(errors[0])]
    heapq.heapify(pq)

    h, w = errors.shape
    seen = set()

    while pq:
        error, path = heapq.heappop(pq)
        curDepth = len(path)
        curIndex = path[-1]

        if curDepth == h:
            return path

        for delta in -1, 0, 1:
            nextIndex = curIndex + delta

            if 0 <= nextIndex < w:
                if (curDepth, nextIndex) not in seen:
                    cumError = error + errors[curDepth, nextIndex]
                    heapq.heappush(pq, (cumError, path + [nextIndex]))
                    seen.add((curDepth, nextIndex))


def minCutPath2(errors):
    # dynamic programming, unused
    errors = np.pad(errors, [(0, 0), (1, 1)], 
                    mode='constant', 
                    constant_values=np.inf)

    cumError = errors[0].copy()
    paths = np.zeros_like(errors, dtype=int)    

    for i in range(1, len(errors)):
        M = cumError
        L = np.roll(M, 1)
        R = np.roll(M, -1)

        # optimize with np.choose?
        cumError = np.min((L, M, R), axis=0) + errors[i]
        paths[i] = np.argmin((L, M, R), axis=0)
    
    paths -= 1
    
    minCutPath = [np.argmin(cumError)]
    for i in reversed(range(1, len(errors))):
        minCutPath.append(minCutPath[-1] + paths[i][minCutPath[-1]])
    
    return map(lambda x: x - 1, reversed(minCutPath))


def minCutPatch(patch, patchLength, overlap, res, y, x):
    patch = patch.copy()
    dy, dx, _ = patch.shape
    minCut = np.zeros_like(patch, dtype=bool)

    if x > 0:
        left = patch[:, :overlap] - res[y:y+dy, x:x+overlap]
        leftL2 = np.sum(left**2, axis=2)
        for i, j in enumerate(minCutPath(leftL2)):
            minCut[i, :j] = True

    if y > 0:
        up = patch[:overlap, :] - res[y:y+overlap, x:x+dx]
        upL2 = np.sum(up**2, axis=2)
        for j, i in enumerate(minCutPath(upL2.T)):
            minCut[:i, j] = True

    np.copyto(patch, res[y:y+dy, x:x+dx], where=minCut)
    # plt.figure()
    # plt.imshow(minCut)
    # plt.show()
    return patch


def set_margin_color_to_guide_initial_patch(rgb_canvas, t_compl_res, target_osm_res, R=100.0, G=100.0, B=100.0):
    '''
    We fill in a small portion of the canvas to guide the selection of the first patch
    in the upper left corner
    '''
    rgb_canvas[0:target_osm_res, 0:t_compl_res, 0] = R
    rgb_canvas[0:target_osm_res, 0:t_compl_res, 0] = G
    rgb_canvas[0:target_osm_res, 0:t_compl_res, 0] = B


def demo_random_Poitiers():
    overlap_factor = 0.1875
    base_path = 'C:/DATASETs/UC2Synthesis/OSM/'
    real_osm_res = 566
    target_osm_res = 512
    t_ovelap_margin = int(target_osm_res*overlap_factor)
    # number pixels in the scaled patch without the overlaping margin:
    t_compl_res = target_osm_res - t_ovelap_margin 

    print(t_ovelap_margin)
    city_id = available_cities_IDs[3]
    output_filename = f'./assembled_{city_id}.jpg'
    max_col, max_row = check_extent_file(city_id, base_path)   
    target_assembled_size_px_rows = target_osm_res + (max_row-1)*t_compl_res
    target_assembled_size_px_cols = target_osm_res + (max_col-1)*t_compl_res
    
    rgb_canvas = np.zeros((target_assembled_size_px_rows, target_assembled_size_px_cols, 3))
    print(max_col, max_row)
    print(rgb_canvas.shape)
    col_i = 0
    for col in range(max_col):
        row_i = max_row - 1
        for row in range(max_row):
            rgb_original_patch = get_osm_image(base_path, city_id, col, row)
            rgb_scaled_patch = resize_image_with_filter(rgb_original_patch, (target_osm_res,target_osm_res))

            min_row_patch = row_i*t_compl_res
            min_col_patch = col_i*t_compl_res
            max_row_patch = min_row_patch + target_osm_res
            max_col_patch = min_col_patch + target_osm_res
            rgb_canvas[min_row_patch:max_row_patch,min_col_patch:max_col_patch,:] = rgb_scaled_patch[:,:,:]
            row_i = row_i - 1
        col_i = col_i + 1

    save_rgb_image(rgb_canvas, output_filename)



def generate_assembly_for_all_cities(IR_flag, mode, num_variations, overlap_factor, max_cloud_size_px):
    if IR_flag:
        spec_mode = 'IR'
    else:
        spec_mode = 'RGB'
    npz_base_path = 'C:/DATASETs/UC2Synthesis/OSM/'
    input_base_path = f'C:/DATASETs/UC2Synthesis/Synth{spec_mode}/'
    output_path = f'C:/DATASETs/UC2Synthesis/assembled.cloud{max_cloud_size_px}/'
    real_osm_res = 566
    target_osm_res = 512
    t_ovelap_margin = int(target_osm_res*overlap_factor)
    # number pixels in the scaled patch without the overlaping margin:
    t_compl_res = target_osm_res - t_ovelap_margin 

    for city_id in available_cities_IDs:   
        for var_i in range(num_variations):
            print('')
            print(f'New variation : {var_i}')
            print(f'pixel overlap: {t_ovelap_margin}')
            original_output_filename = f'./assembled_{city_id}_{spec_mode}_v{var_i}.png'
            S2scaled_output_filename = f'./assembled_S2_{city_id}_{spec_mode}_v{var_i}.png'
            max_col, max_row = check_extent_file(city_id, npz_base_path)   
            target_assembled_size_px_rows = target_osm_res + (max_row-1)*t_compl_res
            target_assembled_size_px_cols = target_osm_res + (max_col-1)*t_compl_res
            
            rgb_canvas = np.zeros((target_assembled_size_px_rows, target_assembled_size_px_cols, 3))
            ir_canvas = np.zeros((target_assembled_size_px_rows, target_assembled_size_px_cols, 3))
            print(max_col, max_row)
            print(rgb_canvas.shape)
            set_margin_color_to_guide_initial_patch(rgb_canvas, t_compl_res, target_osm_res, R=180.0, G=20.0, B=220.0)
            canvas_patch_row_i = 0
            for row in range(max_row-1,-1,-1):
                canvas_patch_col_i = 0
                for col in range(max_col):    
                    # Calculate target coordinates
                    canvas_pixel_y_ini = canvas_patch_row_i*t_compl_res
                    canvas_pixel_x_ini = canvas_patch_col_i*t_compl_res
                    canvas_pixel_y_end = canvas_pixel_y_ini + target_osm_res
                    canvas_pixel_x_end = canvas_pixel_x_ini + target_osm_res
                    # Select the optimal patch among the available ones
                    if mode == 'random' or (row == max_row-1 and col == 0):
                        selected_patch = selectRandomPatch(spec_mode, input_base_path, city_id, col, row, target_osm_res)
                    else: # 'best' or 'cut'                  
                        selected_patch = selectBestPatch(spec_mode, input_base_path, city_id, col, row, target_osm_res, t_ovelap_margin, rgb_canvas, canvas_pixel_y_ini, canvas_pixel_x_ini, max_cloud_size_px)
                        if mode == "cut":
                            selected_patch = minCutPatch(selected_patch, target_osm_res, t_ovelap_margin, rgb_canvas, canvas_pixel_y_ini, canvas_pixel_x_ini)

                    print(f' col : {col}  row : {row}')
                    # Apply minimal cut & patch quilting
                    rgb_canvas[canvas_pixel_y_ini:canvas_pixel_y_end,canvas_pixel_x_ini:canvas_pixel_x_end,:] = selected_patch[:,:,:]
                    canvas_patch_col_i = canvas_patch_col_i + 1
                canvas_patch_row_i = canvas_patch_row_i + 1

            # io.imshow(rgb_canvas/255.0)
            # io.show()
            save_rgb_image(rgb_canvas, output_path + original_output_filename)
            # TODO: Precise scaling to Sentinel-2 pixel scale (10m/px)
            #       Which depends on the latitude and the number of patches per col & row


if __name__ == '__main__':
    # IR_flag = False # True # False # True # False # True
    visible_or_IR = [True, False]
    operation_mode = 'cut' # 'best' # 'random'
    num_variations = 15
    overlap_factor = 0.1875
    max_cloud_size_px = 702 #2500
    spectrum_band_flag = True
    generate_assembly_for_all_cities(spectrum_band_flag, operation_mode, num_variations, overlap_factor, max_cloud_size_px)







