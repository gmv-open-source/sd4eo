# File Name:     osm_assembly.py
# License:       Apache 2.0 License
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		
# Description: 
# This script analyses the content in a folder and generates the corresponding 
# "big assembled image" for a target overlapping factor
#
# Note: we expect OSM patches to have been generated by 
#       LargeScaleDatasetPreparation/get_slide_OSM_patches_in_region.py script
#       which only can be run inside QGIS (with a previous warm-up process)

import cv2
import heapq
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from scipy.ndimage import gaussian_filter
from skimage.transform import resize
from skimage import io, util
import time
import math
import os

available_cities_IDs = ['Madrid', 'Paris', 'Toulouse', 'Poitiers', 'Bordeaux', 'Limoges', 'Clermont-Ferrand', 'Troyes', 'Le Mans', 'Angers', 'Niort',] # 'Rouen']


def check_file_exists(file_path: str) -> bool:
    """Checks if a file exists at the specified path.

    Args:
        file_path (str): The full path of the file to check.

    Returns:
        bool: True if the file exists, False otherwise.
    """
    return os.path.isfile(file_path)

def get_osm_image(base_path, city_id, col, row):
    osm_566_path = base_path + city_id + '/'
    filename = f'patch_{city_id}_{col:03}_{row:03}_OSM.png'
    if check_file_exists(osm_566_path + filename):
        condition_map = cv2.imread(osm_566_path + filename)
        # Do not forget that OpenCV read images in BGR order.
        condition_map = cv2.cvtColor(condition_map, cv2.COLOR_BGR2RGB)
        # Careful!!! Surce image was normalized to possitive values: [0, 1].
        # While target S2 RGB images were normalized in a different way [-1, 1].
        condition_map = condition_map.astype(np.float32)
    else:
        condition_map = None
    return condition_map


def save_rgb_image(image_array: np.ndarray, file_path: str) -> None:
    """Saves a 3D numpy array (RGB image) to disk as an image file.
    
    Args:
        image_array (np.ndarray): A 3D numpy array of type float with shape (height, width, 3).
                                  Values are expected to be in the range [0, 255].
        file_path (str): The path where the image will be saved.
        
    Raises:
        ValueError: If the input array is not a 3D array with 3 channels (RGB).
    """
    # Check if the input array has the correct shape
    if image_array.ndim != 3 or image_array.shape[2] != 3:
        raise ValueError("Input array must be a 3D array with shape (height, width, 3).")
    # Ensure the array values are within the expected range
    image_array = np.clip(image_array, 0, 255)
    # Convert the float array to uint8
    image_array = image_array.astype(np.uint8)
    # Create a PIL image from the numpy array
    image = Image.fromarray(image_array)
    # Save the image to the specified file path
    image.save(file_path)


def resize_image_with_filter(image: np.ndarray, new_size: tuple) -> np.ndarray:
    """
    Resizes a 3D numpy array representing an RGB image to a new specified size after applying a Gaussian filter.
    
    Args:
        image (np.ndarray): 3D numpy array of shape (height, width, 3) representing the input RGB image.
        new_size (tuple): Tuple (new_height, new_width) specifying the desired output image size.
        
    Returns:
        np.ndarray: 3D numpy array of shape (new_height, new_width, 3) representing the resized RGB image.
    """
    # Apply Gaussian filter to smooth the image and avoid aliasing artifacts
    # filtered_image = gaussian_filter(image, sigma=1)
    
    # Resize the filtered image to the new size
    resized_image = resize(image, new_size, anti_aliasing=True, mode='reflect')
    return resized_image


def check_extent_file(city_id, base_path):
    filename = f'np_extent_{city_id}_EPSG_3857.npz'
    extent_file = np.load(base_path + filename)
    extent_reg = extent_file['extent_reg']
    return extent_reg.shape[0], extent_reg.shape[1]



if __name__ == '__main__':
    overlap_factor = 0.1875
    base_path = 'C:/DATASETs/UC2Synthesis/OSM.deleted/'
    real_osm_res = 566
    target_osm_res = 512
    t_ovelap_margin = int(target_osm_res*overlap_factor)
    # number pixels in the scaled patch without the overlaping margin:
    t_compl_res = target_osm_res - t_ovelap_margin 

    print(t_ovelap_margin)
    for city_id in available_cities_IDs:
        output_filename = f'./assembled_{city_id}_OSM-selected_patches.jpg'
        max_col, max_row = check_extent_file(city_id, base_path)   
        target_assembled_size_px_rows = target_osm_res + (max_row-1)*t_compl_res
        target_assembled_size_px_cols = target_osm_res + (max_col-1)*t_compl_res
        
        rgb_canvas = np.zeros((target_assembled_size_px_rows, target_assembled_size_px_cols, 3))
        print(max_col, max_row)
        print(rgb_canvas.shape)
        puzzle = np.zeros((max_row, max_col))
        col_i = 0
        for col in range(max_col):
            row_i = max_row - 1
            for row in range(max_row):
                rgb_original_patch = get_osm_image(base_path, city_id, col, row)
                if rgb_original_patch is not None:
                    rgb_scaled_patch = resize_image_with_filter(rgb_original_patch, (target_osm_res,target_osm_res))

                    min_row_patch = row_i*t_compl_res
                    min_col_patch = col_i*t_compl_res
                    max_row_patch = min_row_patch + target_osm_res
                    max_col_patch = min_col_patch + target_osm_res
                    rgb_canvas[min_row_patch:max_row_patch,min_col_patch:max_col_patch,:] = rgb_scaled_patch[:,:,:]
                    puzzle[row,col] = 1
                row_i = row_i - 1
            col_i = col_i + 1

        save_rgb_image(rgb_canvas, output_filename)
        np.savez(f'{city_id}_puzzle.npz', puzzle=puzzle)

