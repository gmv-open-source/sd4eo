# File Name:     mask_assembler.py
# License:       Apache 2.0 License
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		
# Description: 
# This script analyses the content in a folder and generates the corresponding 
# "big assembled image" for a target overlapping factor
#
# Note: we expect mask patches to have been generated by mask_OSM_gen.py script
#       which generates two boolean 2D numpy arrays in teh same npz file
#       at original resolution (typically 566x566)

import cv2
import heapq
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from scipy.ndimage import gaussian_filter
from skimage.transform import resize
from skimage import io, util
import time
import math

available_cities_IDs = ['Madrid', 'Paris', 'Toulouse', 'Poitiers', 'Bordeaux', 'Limoges', 'Clermont-Ferrand', 'Troyes', 'Le Mans', 'Angers', 'Niort',] # 'Rouen']



def save_rgb_image(image_array: np.ndarray, file_path: str) -> None:
    """Saves a 3D numpy array (RGB image) to disk as an image file.
    
    Args:
        image_array (np.ndarray): A 3D numpy array of type float with shape (height, width, 3).
                                  Values are expected to be in the range [0, 255].
        file_path (str): The path where the image will be saved.
        
    Raises:
        ValueError: If the input array is not a 3D array with 3 channels (RGB).
    """
    # Check if the input array has the correct shape
    if image_array.ndim != 3 or image_array.shape[2] != 3:
        raise ValueError("Input array must be a 3D array with shape (height, width, 3).")
    # Ensure the array values are within the expected range
    image_array = np.clip(image_array, 0, 255)
    # Convert the float array to uint8
    image_array = image_array.astype(np.uint8)
    # Create a PIL image from the numpy array
    image = Image.fromarray(image_array)
    # Save the image to the specified file path
    image.save(file_path)


def resize_image_with_filter(image: np.ndarray, new_size: tuple) -> np.ndarray:
    """
    Resizes a 3D numpy array representing an RGB image to a new specified size after applying a Gaussian filter.
    
    Args:
        image (np.ndarray): 3D numpy array of shape (height, width, 3) representing the input RGB image.
        new_size (tuple): Tuple (new_height, new_width) specifying the desired output image size.
        
    Returns:
        np.ndarray: 3D numpy array of shape (new_height, new_width, 3) representing the resized RGB image.
    """
    # Apply Gaussian filter to smooth the image and avoid aliasing artifacts
    # filtered_image = gaussian_filter(image, sigma=1)
    
    # Resize the filtered image to the new size
    resized_image = resize(image, new_size, anti_aliasing=True, mode='reflect')
    return resized_image


def check_extent_file(city_id, base_path):
    filename = f'np_extent_{city_id}_EPSG_3857.npz'
    extent_file = np.load(base_path + filename)
    extent_reg = extent_file['extent_reg']
    return extent_reg.shape[0], extent_reg.shape[1]

def get_mask_patch_asRGB(input_base_path, city_id, col, row):
    npz_filename = f'mask_{city_id}_c{col:03}_r{row:03}.npz'
    npz_file = np.load(input_base_path +  city_id + '/' + npz_filename)
    all_building_bmask = npz_file['all_building_binary_mask']
    non_residential_bmask = npz_file['non_residential_combined_mask']
    all_building_RGB = np.zeros((all_building_bmask.shape[0], all_building_bmask.shape[1],3))
    non_residential_RGB = np.zeros((non_residential_bmask.shape[0], non_residential_bmask.shape[1],3))
    for i in range(3):
        all_building_RGB[:,:,i] = all_building_bmask[:,:]*255.0
        non_residential_RGB[:,:,i] = non_residential_bmask[:,:]*255.0
    return all_building_RGB, non_residential_RGB



if __name__ == '__main__':
    overlap_factor = 0.1875
    extent_npz_path = 'C:/DATASETs/UC2Synthesis/OSM/'
    input_base_path = 'C:/DATASETs/UC2Synthesis/Mask/'
    real_osm_res = 566
    target_osm_res = 512
    t_ovelap_margin = int(target_osm_res*overlap_factor)
    # number pixels in the scaled patch without the overlaping margin:
    t_compl_res = target_osm_res - t_ovelap_margin 

    print(f'Estimated margin {t_ovelap_margin}px')
    for city_id in available_cities_IDs[-1:]:
        allb_full_output_filename = f'./assembled_{city_id}_full_allbuildingmask.png'
        nonr_full_output_filename = f'./assembled_{city_id}_full_nonresidentialmask.png'
        allb_scaled_output_filename = f'./assembled_{city_id}_scaled_allbuildingmask.png'
        nonr_scaled_output_filename = f'./assembled_{city_id}_scaled_nonresidentialmask.png'
        max_col, max_row = check_extent_file(city_id, extent_npz_path)   
        target_assembled_size_px_rows = target_osm_res + (max_row-1)*t_compl_res
        target_assembled_size_px_cols = target_osm_res + (max_col-1)*t_compl_res
        
        rgb_canvas_allb = np.zeros((target_assembled_size_px_rows, target_assembled_size_px_cols,3))
        rgb_canvas_nonres = np.zeros((target_assembled_size_px_rows, target_assembled_size_px_cols,3))
        print(max_col, max_row)
        print(rgb_canvas_allb.shape)
        col_i = 0
        for col in range(max_col):
            row_i = max_row - 1
            for row in range(max_row):
                rgb_original_allb_patch, rgb_original_nonres_patch = get_mask_patch_asRGB(input_base_path, city_id, col, row)
                rgb_scaled_allb_patch = resize_image_with_filter(rgb_original_allb_patch, (target_osm_res,target_osm_res))
                rgb_scaled_nonres_patch = resize_image_with_filter(rgb_original_nonres_patch, (target_osm_res,target_osm_res))

                min_row_patch = row_i*t_compl_res
                min_col_patch = col_i*t_compl_res
                max_row_patch = min_row_patch + target_osm_res
                max_col_patch = min_col_patch + target_osm_res
                rgb_canvas_allb[min_row_patch:max_row_patch,min_col_patch:max_col_patch,:] = rgb_scaled_allb_patch[:,:,:]
                rgb_canvas_nonres[min_row_patch:max_row_patch,min_col_patch:max_col_patch,:] = rgb_scaled_nonres_patch[:,:,:]
                row_i = row_i - 1
            col_i = col_i + 1

        save_rgb_image(rgb_canvas_allb, allb_full_output_filename)
        save_rgb_image(rgb_canvas_nonres, nonr_full_output_filename)
        # TODO: Estimate scaled size
        scale_factor = 177.0 / target_osm_res*1.0
        print(f'Additional scale factor for S2 : {scale_factor}')
        # TODO: save scaled version as PNG + NPZ

